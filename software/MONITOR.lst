Interrupt Vectors
    00000 940C 0045 JMP	__text_start|__start
    00002 940C 00F2 JMP	_int0_isr
    00004 940C 00FC JMP	_int1_isr
    00012 940C 0163 JMP	_timer0_ovf_isr
    00016 940C 0192 JMP	_uart0_rx_isr

Program Code (text area)
__text_start|__start:
    00045 E5CF      LDI	R28,0x5F
    00046 E0D4      LDI	R29,4
    00047 BFCD      OUT	0x3D,R28
    00048 BFDE      OUT	0x3E,R29
    00049 51CE      SUBI	R28,0x1E
    0004A 40D0      SBCI	R29,0
    0004B EA0A      LDI	R16,0xAA
    0004C 8308      ST	Y,R16
    0004D 2400      CLR	R0
    0004E E9E5      LDI	R30,0x95
    0004F E0F0      LDI	R31,0
    00050 E011      LDI	R17,1
    00051 31EF      CPI	R30,0x1F
    00052 07F1      CPC	R31,R17
    00053 F011      BEQ	0x0056
    00054 9201      ST	Z+,R0
    00055 CFFB      RJMP	0x0051
    00056 8300      ST	Z,R16
    00057 E5E4      LDI	R30,0x54
    00058 E0F0      LDI	R31,0
    00059 E6A0      LDI	R26,0x60
    0005A E0B0      LDI	R27,0
    0005B E010      LDI	R17,0
    0005C E000      LDI	R16,0
    0005D BF0B      OUT	0x3B,R16
    0005E 38E9      CPI	R30,0x89
    0005F 07F1      CPC	R31,R17
    00060 F021      BEQ	0x0065
    00061 95C8      LPM
    00062 9631      ADIW	R30,1
    00063 920D      ST	X+,R0
    00064 CFF9      RJMP	0x005E
    00065 940E 007F CALL	_main
_exit:
    00067 CFFF      RJMP	_exit
FILE: D:\monitor\software\source\main.c
(0001) #include "define.h"
(0002) #include "uart.h"
(0003) #include "eeprom1.h"
(0004) #include "string.h"
(0005) 
(0006) 
(0007) u8 okflag;
(0008) u8 errflag;
(0009) u8 readflag;
(0010) u8 keyflag;
(0011) u8 key[10];
(0012) u8 key_old[10];
(0013) u8 phnum[12];
(0014) u8 mstxt[100];
(0015) u8 shefang;
(0016) u8 newms;
(0017) void AT_init(void)
(0018) {
(0019) 	okflag = 0;
_AT_init:
    00068 2422      CLR	R2
    00069 9220 011E STS	okflag,R2
(0020) 	USART_send_str("AT+CMGF=1");//设置TXT 格式
    0006B E605      LDI	R16,0x65
    0006C E010      LDI	R17,0
    0006D 940E 017D CALL	_USART_send_str
(0021) 	while(!okflag);
    0006F 9020 011E LDS	R2,okflag
    00071 2022      TST	R2
    00072 F3E1      BEQ	0x006F
(0022) 	okflag = 0;
    00073 2422      CLR	R2
    00074 9220 011E STS	okflag,R2
(0023) 	USART_send_str("ATS0");//设置自动接听
    00076 E600      LDI	R16,0x60
    00077 E010      LDI	R17,0
    00078 940E 017D CALL	_USART_send_str
(0024) 	while(!okflag);
    0007A 9020 011E LDS	R2,okflag
    0007C 2022      TST	R2
    0007D F3E1      BEQ	0x007A
    0007E 9508      RET
_main:
    0007F 9722      SBIW	R28,2
(0025) 	
(0026) }
(0027) void main(void )
(0028) {
(0029) 	init_devices();
    00080 940E 0138 CALL	_init_devices
(0030) 	AT_init();
    00082 DFE5      RCALL	_AT_init
(0031) 	for(;;){
(0032) 
(0033) 		if(newms){
    00083 9020 0095 LDS	R2,newms
    00085 2022      TST	R2
    00086 F029      BEQ	0x008C
(0034) 			read_message();
    00087 940E 0246 CALL	_read_message
(0035) 			newms = 0;
    00089 2422      CLR	R2
    0008A 9220 0095 STS	newms,R2
(0036) 		}
(0037) 		keyflag = EEPROM_read_byte(key_flag_addr);
    0008C E10E      LDI	R16,0x1E
    0008D E010      LDI	R17,0
    0008E 940E 020E CALL	_EEPROM_read_byte
    00090 9300 011B STS	keyflag,R16
(0038) 		if(!keyflag){
    00092 2300      TST	R16
    00093 F529      BNE	0x00B9
(0039) 			if(okflag){
    00094 9020 011E LDS	R2,okflag
    00096 2022      TST	R2
    00097 F359      BEQ	0x0083
(0040) 				okflag = 0;
    00098 2422      CLR	R2
    00099 9220 011E STS	okflag,R2
(0041) 				if(!pass_key()){
    0009B 940E 0299 CALL	_pass_key
    0009D 3000      CPI	R16,0
    0009E 0701      CPC	R16,R17
    0009F F491      BNE	0x00B2
(0042) 					keyflag = 1;
    000A0 E081      LDI	R24,1
    000A1 9380 011B STS	keyflag,R24
(0043) 					EEPROM_write_byte(key_flag_addr,1);
    000A3 E021      LDI	R18,1
    000A4 E10E      LDI	R16,0x1E
    000A5 E010      LDI	R17,0
    000A6 940E 0206 CALL	_EEPROM_write_byte
(0044) 					EEPROM_write(key_addr,key,key_length);
    000A8 E086      LDI	R24,6
    000A9 E090      LDI	R25,0
    000AA 8399      STD	Y+1,R25
    000AB 8388      ST	Y,R24
    000AC E121      LDI	R18,0x11
    000AD E031      LDI	R19,1
    000AE E104      LDI	R16,0x14
    000AF E010      LDI	R17,0
    000B0 940E 0215 CALL	_EEPROM_write
(0045) 
(0046) 				}
(0047) 				
(0048) 				if(!pass_phnum()){
    000B2 940E 026B CALL	_pass_phnum
    000B4 0158      MOVW	R10,R16
    000B5 3000      CPI	R16,0
    000B6 0701      CPC	R16,R17
    000B7 F659      BNE	0x0083
(0049) 					;
(0050) 				}
(0051) 			}	
(0052) 		}
    000B8 CFCA      RJMP	0x0083
(0053) 		else{
(0054) 			if(okflag){
    000B9 9020 011E LDS	R2,okflag
    000BB 2022      TST	R2
    000BC F231      BEQ	0x0083
(0055) 				okflag = 0;
    000BD 2422      CLR	R2
    000BE 9220 011E STS	okflag,R2
(0056) 				if(!pass_key()){
    000C0 940E 0299 CALL	_pass_key
    000C2 0158      MOVW	R10,R16
    000C3 3000      CPI	R16,0
    000C4 0701      CPC	R16,R17
    000C5 F511      BNE	0x00E8
(0057) 					EEPROM_read(key_addr,key_old,key_length);
    000C6 E086      LDI	R24,6
    000C7 E090      LDI	R25,0
    000C8 8399      STD	Y+1,R25
    000C9 8388      ST	Y,R24
    000CA E027      LDI	R18,7
    000CB E031      LDI	R19,1
    000CC E104      LDI	R16,0x14
    000CD E010      LDI	R17,0
    000CE 940E 022D CALL	_EEPROM_read
(0058) 					if(!memcmp(key,key_old,key_length)){
    000D0 E086      LDI	R24,6
    000D1 E090      LDI	R25,0
    000D2 8399      STD	Y+1,R25
    000D3 8388      ST	Y,R24
    000D4 E027      LDI	R18,7
    000D5 E031      LDI	R19,1
    000D6 E101      LDI	R16,0x11
    000D7 E011      LDI	R17,1
    000D8 940E 0333 CALL	_memcmp
    000DA 0158      MOVW	R10,R16
    000DB 3000      CPI	R16,0
    000DC 0701      CPC	R16,R17
    000DD F451      BNE	0x00E8
(0059) 						EEPROM_write(key_addr,key,key_length);
    000DE E086      LDI	R24,6
    000DF E090      LDI	R25,0
    000E0 8399      STD	Y+1,R25
    000E1 8388      ST	Y,R24
    000E2 E121      LDI	R18,0x11
    000E3 E031      LDI	R19,1
    000E4 E104      LDI	R16,0x14
    000E5 E010      LDI	R17,0
    000E6 940E 0215 CALL	_EEPROM_write
(0060) 					}
(0061) 
(0062) 				}
(0063) 				
(0064) 				if(!pass_phnum()){
    000E8 940E 026B CALL	_pass_phnum
    000EA 0158      MOVW	R10,R16
    000EB 3000      CPI	R16,0
    000EC 0701      CPC	R16,R17
    000ED F009      BEQ	0x00EF
    000EE CF94      RJMP	0x0083
    000EF CF93      RJMP	0x0083
    000F0 9622      ADIW	R28,2
    000F1 9508      RET
_int0_isr:
    000F2 938A      ST	-Y,R24
    000F3 B78F      IN	R24,0x3F
    000F4 938A      ST	-Y,R24
FILE: D:\monitor\software\source\extint.c
(0001) 
(0002) #include "define.h"
(0003) #include "func.h"
(0004) 
(0005) extern u8 newms;
(0006) #pragma interrupt_handler int0_isr:iv_INT0
(0007) 
(0008) extern u8 phnum[12];
(0009) void int0_isr(void)
(0010) {
(0011) 	newms = 1;
    000F5 E081      LDI	R24,1
    000F6 9380 0095 STS	newms,R24
    000F8 9189      LD	R24,Y+
    000F9 BF8F      OUT	0x3F,R24
    000FA 9189      LD	R24,Y+
    000FB 9518      RETI
_int1_isr:
    000FC 920A      ST	-Y,R0
    000FD 921A      ST	-Y,R1
    000FE 922A      ST	-Y,R2
    000FF 923A      ST	-Y,R3
    00100 924A      ST	-Y,R4
    00101 925A      ST	-Y,R5
    00102 926A      ST	-Y,R6
    00103 927A      ST	-Y,R7
    00104 928A      ST	-Y,R8
    00105 929A      ST	-Y,R9
    00106 930A      ST	-Y,R16
    00107 931A      ST	-Y,R17
    00108 932A      ST	-Y,R18
    00109 933A      ST	-Y,R19
    0010A 938A      ST	-Y,R24
    0010B 939A      ST	-Y,R25
    0010C 93AA      ST	-Y,R26
    0010D 93BA      ST	-Y,R27
    0010E 93EA      ST	-Y,R30
    0010F 93FA      ST	-Y,R31
    00110 B60F      IN	R0,0x3F
    00111 920A      ST	-Y,R0
(0012) }
(0013) 
(0014) #pragma interrupt_handler int1_isr:iv_INT1
(0015) void int1_isr(void)
(0016) {
(0017) 	 //external interupt on INT1
(0018) 	 //u8 data;
(0019) 	 //EEPROM_read(phnum_addr,phnum,phnum_length);
(0020) 	// USART_send_str(phnum);
(0021) 	phcall();
    00112 940E 030F CALL	_phcall
    00114 9009      LD	R0,Y+
    00115 BE0F      OUT	0x3F,R0
    00116 91F9      LD	R31,Y+
    00117 91E9      LD	R30,Y+
    00118 91B9      LD	R27,Y+
    00119 91A9      LD	R26,Y+
    0011A 9199      LD	R25,Y+
    0011B 9189      LD	R24,Y+
    0011C 9139      LD	R19,Y+
    0011D 9129      LD	R18,Y+
    0011E 9119      LD	R17,Y+
    0011F 9109      LD	R16,Y+
    00120 9099      LD	R9,Y+
    00121 9089      LD	R8,Y+
    00122 9079      LD	R7,Y+
    00123 9069      LD	R6,Y+
    00124 9059      LD	R5,Y+
    00125 9049      LD	R4,Y+
    00126 9039      LD	R3,Y+
    00127 9029      LD	R2,Y+
    00128 9019      LD	R1,Y+
    00129 9009      LD	R0,Y+
    0012A 9518      RETI
FILE: D:\monitor\software\source\init.c
(0001) #include "define.h"
(0002) #include "timer.h"
(0003) #include "spi.h"
(0004) #include "uart.h"
(0005) void port_init(void)
(0006) {
(0007) 	 PORTA = 0x00;
_port_init:
    0012B 2422      CLR	R2
    0012C BA2B      OUT	0x1B,R2
(0008) 	 DDRA  = 0x00;
    0012D BA2A      OUT	0x1A,R2
(0009) 	 PORTB = 0x00;
    0012E BA28      OUT	0x18,R2
(0010) 	 DDRB  = 0x00;
    0012F BA27      OUT	0x17,R2
(0011) 	 PORTC = 0x00; //m103 output only
    00130 BA25      OUT	0x15,R2
(0012) 	 DDRC  = 0x00;
    00131 BA24      OUT	0x14,R2
(0013) 	 PORTD = 0x00;
    00132 BA22      OUT	0x12,R2
(0014) 	 DDRD  = 0x02;
    00133 E082      LDI	R24,2
    00134 BB81      OUT	0x11,R24
    00135 9508      RET
(0015) }
(0016) 
(0017) //Watchdog initialize
(0018) // prescale: 32K 
(0019) void watchdog_init(void)
(0020) {
(0021) 	 WDR(); //this prevents a timout on enabling
_watchdog_init:
    00136 95A8      WDR
    00137 9508      RET
(0022) 	 #ifdef CLOCK11059
(0023) 	 WDTCR = 0x09; //WATCHDOG ENABLED - dont forget to issue WDRs
(0024) 	 #endif
(0025) 	 #ifdef CLOCK73728
(0026) 
(0027) 	 #endif
(0028) }
(0029) 
(0030) //call this routine to initialize all peripherals
(0031) void init_devices(void)
(0032) {
(0033)  //stop errant interrupts until set up
(0034) 	 CLI(); //disable all interrupts
_init_devices:
    00138 94F8      BCLR	7
(0035) 	 port_init();
    00139 DFF1      RCALL	_port_init
(0036) 	 watchdog_init();
    0013A DFFB      RCALL	_watchdog_init
(0037) 	 timer0_init();
    0013B 940E 015A CALL	_timer0_init
(0038) 	 spi_init();
    0013D 940E 014B CALL	_spi_init
(0039) 	 uart0_init();
    0013F 940E 016D CALL	_uart0_init
(0040) 	 SPI_MasterInit();
    00141 940E 0150 CALL	_SPI_MasterInit
(0041) 
(0042) 	 MCUCR = 0x0A;
    00143 E08A      LDI	R24,0xA
    00144 BF85      OUT	0x35,R24
(0043) 	 GICR  = 0xC0;
    00145 EC80      LDI	R24,0xC0
    00146 BF8B      OUT	0x3B,R24
(0044) 	 TIMSK = 0x01; //timer interrupt sources
    00147 E081      LDI	R24,1
    00148 BF89      OUT	0x39,R24
(0045) 	 SEI(); //re-enable interrupts
    00149 9478      BSET	7
    0014A 9508      RET
FILE: D:\monitor\software\source\spi.c
(0001) #include "define.h"
(0002) 
(0003) //SPI initialize
(0004) // clock rate: 2764749hz
(0005) void spi_init(void)
(0006) {
(0007) 	 SPCR = 0x50; //setup SPI
_spi_init:
    0014B E580      LDI	R24,0x50
    0014C B98D      OUT	0x0D,R24
(0008) 	 SPSR = 0x00; //setup SPI
    0014D 2422      CLR	R2
    0014E B82E      OUT	0x0E,R2
    0014F 9508      RET
(0009) }
(0010) 
(0011) void SPI_MasterInit(void)
(0012) {
(0013) 	/* 设置MOSI 和SCK 为输出，其他为输入 */
(0014) 	DDRB |= (1<<5)|(1<<7)|(1<<4);
_SPI_MasterInit:
    00150 B387      IN	R24,0x17
    00151 6B80      ORI	R24,0xB0
    00152 BB87      OUT	0x17,R24
(0015) 	/* 使能SPI 主机模式，设置时钟速率为fck/16 */
(0016) 	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
    00153 E581      LDI	R24,0x51
    00154 B98D      OUT	0x0D,R24
    00155 9508      RET
(0017) }
(0018) void SPI_MasterTransmit(u8 cData)
(0019) {
(0020) 	/* 启动数据传输 */
(0021) 	SPDR = cData;
_SPI_MasterTransmit:
  cData                --> R16
    00156 B90F      OUT	0x0F,R16
(0022) 	/* 等待传输结束 */
(0023) 	while(!(SPSR & (1<<SPIF)))
    00157 9B77      SBIS	0x0E,7
    00158 CFFE      RJMP	0x0157
    00159 9508      RET
FILE: D:\monitor\software\source\timer.c
(0001) #include "define.h"
(0002) //TIMER0 initialize - prescale:1024
(0003) // WGM: Normal
(0004) // desired value: 1KHz
(0005) // actual value:  1.080KHz (7.4%)
(0006) void timer0_init(void)
(0007) {
(0008) #ifdef CLOCK11059
(0009) 	 TCCR0 = 0x00; //stop
(0010) 	 TCNT0 = 0xF6; //set count
(0011) 	 OCR0  = 0x0A;  //set compare
(0012) 	 TCCR0 = 0x05; //start timer
(0013) #endif
(0014) #ifdef CLOCK73728
(0015) 	TCCR0 = 0x00; //stop
_timer0_init:
    0015A 2422      CLR	R2
    0015B BE23      OUT	0x33,R2
(0016) 	TCNT0 = 0x8D; //set count
    0015C E88D      LDI	R24,0x8D
    0015D BF82      OUT	0x32,R24
(0017) 	OCR0  = 0x73;  //set compare
    0015E E783      LDI	R24,0x73
    0015F BF8C      OUT	0x3C,R24
(0018) 	TCCR0 = 0x03; //start timer
    00160 E083      LDI	R24,3
    00161 BF83      OUT	0x33,R24
    00162 9508      RET
_timer0_ovf_isr:
    00163 938A      ST	-Y,R24
    00164 B78F      IN	R24,0x3F
    00165 938A      ST	-Y,R24
(0019) 
(0020) #endif
(0021) }
(0022) 
(0023) #pragma interrupt_handler timer0_ovf_isr:iv_TIM0_OVF
(0024) void timer0_ovf_isr(void)
(0025) {
(0026) 	static int a=0;
(0027) #ifdef CLOCK11059
(0028) 	 TCNT0 = 0xF6; //reload counter value
(0029) #endif
(0030) #ifdef CLOCK73728
(0031) 	 TCNT0 = 0x8D; //reload counter value
    00166 E88D      LDI	R24,0x8D
    00167 BF82      OUT	0x32,R24
(0032) #endif	 
(0033) WDR();
    00168 95A8      WDR
    00169 9189      LD	R24,Y+
    0016A BF8F      OUT	0x3F,R24
    0016B 9189      LD	R24,Y+
    0016C 9518      RETI
FILE: D:\monitor\software\source\uart.c
(0001) #include "define.h"
(0002) 
(0003) //UART0 initialize
(0004) // desired baud rate: 115200
(0005) // actual: baud rate:115198 (0.0%)
(0006) extern okflag;
(0007) extern u8 mstxt[100];
(0008) void uart0_init(void)
(0009) {
(0010) 	DDRD |= 1<<1; 
_uart0_init:
    0016D 9A89      SBI	0x11,1
(0011) #ifdef CLOCK11059
(0012) #ifdef UART115200
(0013) 	 UCSRB = 0x00; //disable while setting baud rate
(0014) 	 UCSRA = 0x00;
(0015) 	 UCSRC = BIT(URSEL) | 0x06;
(0016) 	 UBRRL = 0x05; //set baud rate lo
(0017) 	 UBRRH = 0x00; //set baud rate hi
(0018) 	 UCSRB = 0x98;
(0019) #endif
(0020) #ifdef UART57600
(0021) 	 UCSRB = 0x00; //disable while setting baud rate
(0022) 	 UCSRA = 0x00;
(0023) 	 UCSRC = BIT(URSEL) | 0x06;
(0024) 	 UBRRL = 0x0B; //set baud rate lo
(0025) 	 UBRRH = 0x00; //set baud rate hi
(0026) 	 UCSRB = 0x98;
(0027) #endif
(0028) #endif
(0029) #ifdef CLOCK73728
(0030) #ifdef UART115200
(0031) 	UCSRB = 0x00; //disable while setting baud rate
(0032) 	UCSRA = 0x00;
(0033) 	UCSRC = BIT(URSEL) | 0x06;
(0034) 	UBRRL = 0x03; //set baud rate lo
(0035) 	UBRRH = 0x00; //set baud rate hi
(0036) 	UCSRB = 0x98;
(0037) 
(0038) #endif
(0039) #ifdef UART57600
(0040) 	UCSRB = 0x00; //disable while setting baud rate
(0041) 	UCSRA = 0x00;
(0042) 	UCSRC = BIT(URSEL) | 0x06;
(0043) 	UBRRL = 0x07; //set baud rate lo
(0044) 	UBRRH = 0x00; //set baud rate hi
(0045) 	UCSRB = 0x98;
(0046) 
(0047) #endif
(0048) #ifdef UART9600
(0049) UCSRB = 0x00; //disable while setting baud rate
    0016E 2422      CLR	R2
    0016F B82A      OUT	0x0A,R2
(0050) UCSRA = 0x00;
    00170 B82B      OUT	0x0B,R2
(0051) UCSRC = BIT(URSEL) | 0x06;
    00171 E886      LDI	R24,0x86
    00172 BD80      OUT	0x20,R24
(0052) 
(0053) UBRRL = 0x2F; //set baud rate lo
    00173 E28F      LDI	R24,0x2F
    00174 B989      OUT	0x09,R24
(0054) UBRRH = 0x00; //set baud rate hi
    00175 BC20      OUT	0x20,R2
(0055) UCSRB = 0x98;
    00176 E988      LDI	R24,0x98
    00177 B98A      OUT	0x0A,R24
    00178 9508      RET
(0056) 
(0057) #endif
(0058) #endif
(0059) }
(0060) 
(0061) void USART_Transmit( unsigned char data )     //发送模块，该程序没用到
(0062) {
(0063) 	/* Wait for empty transmit buffer */
(0064) 	while( !( UCSRA & (1<<UDRE)))/* Put data into buffer, sends the data */
_USART_Transmit:
  data                 --> R16
    00179 9B5D      SBIS	0x0B,5
    0017A CFFE      RJMP	_USART_Transmit
(0065) 		;
(0066) 	UDR = data;
    0017B B90C      OUT	0x0C,R16
    0017C 9508      RET
_USART_send_str:
  i                    --> R10
  str                  --> R20
    0017D 940E 037B CALL	push_xgset300C
    0017F 01A8      MOVW	R20,R16
(0067) }
(0068) void USART_send_str(unsigned char * str)		//发送字符串
(0069) {
(0070) 	int i=0;
    00180 24AA      CLR	R10
    00181 24BB      CLR	R11
    00182 C004      RJMP	0x0187
(0071) 	while(*(str++)!= 0){
(0072) 		USART_Transmit(*(str-1));
    00183 01FA      MOVW	R30,R20
    00184 9731      SBIW	R30,1
    00185 8100      LD	R16,Z
    00186 DFF2      RCALL	_USART_Transmit
    00187 01FA      MOVW	R30,R20
    00188 9021      LD	R2,Z+
    00189 01AF      MOVW	R20,R30
    0018A 2022      TST	R2
    0018B F7B9      BNE	0x0183
(0073) 	}
(0074) 	USART_Transmit('\r');
    0018C E00D      LDI	R16,0xD
    0018D DFEB      RCALL	_USART_Transmit
(0075) 	USART_Transmit('\n');
    0018E E00A      LDI	R16,0xA
    0018F DFE9      RCALL	_USART_Transmit
    00190 940C 0380 JMP	pop_xgset300C
_uart0_rx_isr:
  data                 --> R20
    00192 920A      ST	-Y,R0
    00193 921A      ST	-Y,R1
    00194 922A      ST	-Y,R2
    00195 923A      ST	-Y,R3
    00196 924A      ST	-Y,R4
    00197 925A      ST	-Y,R5
    00198 926A      ST	-Y,R6
    00199 927A      ST	-Y,R7
    0019A 928A      ST	-Y,R8
    0019B 929A      ST	-Y,R9
    0019C 930A      ST	-Y,R16
    0019D 931A      ST	-Y,R17
    0019E 932A      ST	-Y,R18
    0019F 933A      ST	-Y,R19
    001A0 938A      ST	-Y,R24
    001A1 939A      ST	-Y,R25
    001A2 93AA      ST	-Y,R26
    001A3 93BA      ST	-Y,R27
    001A4 93EA      ST	-Y,R30
    001A5 93FA      ST	-Y,R31
    001A6 B60F      IN	R0,0x3F
    001A7 920A      ST	-Y,R0
    001A8 934A      ST	-Y,R20
(0076) }
(0077) 
(0078) #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
(0079) void uart0_rx_isr(void)
(0080) {
(0081) 	 //uart has received a character in UDR
(0082) 	 static u8 flag = 0;
(0083) 	 u8 data;
(0084) 	 static u8 i= 0;
(0085) 	 data = UDR;
    001A9 B14C      IN	R20,0x0C
(0086) 	 if((1==flag)&&('K'==data)){
    001AA 9180 0071 LDS	R24,uart.c:flag
    001AC 3081      CPI	R24,1
    001AD F459      BNE	0x01B9
    001AE 344B      CPI	R20,0x4B
    001AF F449      BNE	0x01B9
(0087) 		 okflag = 1;
    001B0 E081      LDI	R24,1
    001B1 E090      LDI	R25,0
    001B2 9390 011F STS	okflag+1,R25
    001B4 9380 011E STS	okflag,R24
(0088) 		 i=0;
    001B6 2422      CLR	R2
    001B7 9220 0072 STS	uart.c:i,R2
(0089) 	 }
(0090) 	 if('O'==data)
    001B9 344F      CPI	R20,0x4F
    001BA F419      BNE	0x01BE
(0091) 	 	flag = 1;
    001BB E081      LDI	R24,1
    001BC 9380 0071 STS	uart.c:flag,R24
(0092) 
(0093) 	 if((4==flag)&&('G'==data)){
    001BE 9180 0071 LDS	R24,uart.c:flag
    001C0 3084      CPI	R24,4
    001C1 F429      BNE	0x01C7
    001C2 3447      CPI	R20,0x47
    001C3 F419      BNE	0x01C7
(0094) 		 USART_send_str("ATA");
    001C4 E703      LDI	R16,0x73
    001C5 E010      LDI	R17,0
    001C6 DFB6      RCALL	_USART_send_str
(0095) 	 }
(0096) 
(0097) 	 if((3==flag)&&('N'==data)){
    001C7 9180 0071 LDS	R24,uart.c:flag
    001C9 3083      CPI	R24,3
    001CA F429      BNE	0x01D0
    001CB 344E      CPI	R20,0x4E
    001CC F419      BNE	0x01D0
(0098) 		 flag = 4;
    001CD E084      LDI	R24,4
    001CE 9380 0071 STS	uart.c:flag,R24
(0099) 	 }
(0100) 	 if((2==flag)&&('I'==data)){
    001D0 9180 0071 LDS	R24,uart.c:flag
    001D2 3082      CPI	R24,2
    001D3 F429      BNE	0x01D9
    001D4 3449      CPI	R20,0x49
    001D5 F419      BNE	0x01D9
(0101) 		 flag = 3;
    001D6 E083      LDI	R24,3
    001D7 9380 0071 STS	uart.c:flag,R24
(0102) 	 }
(0103) 	 if('R'==data)
    001D9 3542      CPI	R20,0x52
    001DA F419      BNE	0x01DE
(0104) 	 	flag = 2;
    001DB E082      LDI	R24,2
    001DC 9380 0071 STS	uart.c:flag,R24
(0105) 	 
(0106) 	 if(!okflag){
    001DE 9020 011E LDS	R2,okflag
    001E0 9030 011F LDS	R3,okflag+1
    001E2 2022      TST	R2
    001E3 F451      BNE	0x01EE
    001E4 2033      TST	R3
    001E5 F441      BNE	0x01EE
(0107) 		mstxt[i] = data;
    001E6 E987      LDI	R24,0x97
    001E7 E090      LDI	R25,0
    001E8 91E0 0072 LDS	R30,uart.c:i
    001EA 27FF      CLR	R31
    001EB 0FE8      ADD	R30,R24
    001EC 1FF9      ADC	R31,R25
    001ED 8340      ST	Z,R20
(0108) 	 }
    001EE 9149      LD	R20,Y+
    001EF 9009      LD	R0,Y+
    001F0 BE0F      OUT	0x3F,R0
    001F1 91F9      LD	R31,Y+
    001F2 91E9      LD	R30,Y+
    001F3 91B9      LD	R27,Y+
    001F4 91A9      LD	R26,Y+
    001F5 9199      LD	R25,Y+
    001F6 9189      LD	R24,Y+
    001F7 9139      LD	R19,Y+
    001F8 9129      LD	R18,Y+
    001F9 9119      LD	R17,Y+
    001FA 9109      LD	R16,Y+
    001FB 9099      LD	R9,Y+
    001FC 9089      LD	R8,Y+
    001FD 9079      LD	R7,Y+
    001FE 9069      LD	R6,Y+
    001FF 9059      LD	R5,Y+
    00200 9049      LD	R4,Y+
    00201 9039      LD	R3,Y+
    00202 9029      LD	R2,Y+
    00203 9019      LD	R1,Y+
    00204 9009      LD	R0,Y+
    00205 9518      RETI
FILE: D:\monitor\software\source\eeprom.c
(0001) #include "define.h"
(0002) 
(0003) void EEPROM_write_byte(u16 uiAddress,u8 ucData)
(0004) {
(0005) 	/*等待上一次写操作结束*/
(0006) 	while(EECR &(1<<EEWE));
_EEPROM_write_byte:
  ucData               --> R18
  uiAddress            --> R16
    00206 99E1      SBIC	0x1C,1
    00207 CFFE      RJMP	_EEPROM_write_byte
(0007) 	/*设置地址和数据寄存器*/
(0008) 	EEAR=uiAddress;
    00208 BB1F      OUT	0x1F,R17
    00209 BB0E      OUT	0x1E,R16
(0009) 	EEDR=ucData;
    0020A BB2D      OUT	0x1D,R18
(0010) 	/*置位EEMWE*/
(0011) 	EECR|=(1<<EEMWE);
    0020B 9AE2      SBI	0x1C,2
(0012) 	/*置位EEWE?以启动写操作*/
(0013) 	EECR|=(1<<EEWE);
    0020C 9AE1      SBI	0x1C,1
    0020D 9508      RET
(0014) }
(0015) u8 EEPROM_read_byte(u16 uiAddress)
(0016) {
(0017) 	/*等待上一次写操作结束*/
(0018) 	while(EECR & (1<<EEWE));
_EEPROM_read_byte:
  uiAddress            --> R16
    0020E 99E1      SBIC	0x1C,1
    0020F CFFE      RJMP	_EEPROM_read_byte
(0019) 	/*设置地址寄存器*/
(0020) 	EEAR = uiAddress;
    00210 BB1F      OUT	0x1F,R17
    00211 BB0E      OUT	0x1E,R16
(0021) 	/*设置EERE?以启动读操作*/
(0022) 	EECR|=(1<<EERE);
    00212 9AE0      SBI	0x1C,0
(0023) 	/*自数据寄存器返回数据*/
(0024) 	return EEDR;
    00213 B30D      IN	R16,0x1D
    00214 9508      RET
_EEPROM_write:
  i                    --> R20
  length               --> R10
  Data                 --> R12
  uiAddress            --> R14
    00215 940E 0372 CALL	push_xgset30FC
    00217 0169      MOVW	R12,R18
    00218 0178      MOVW	R14,R16
    00219 84A8      LDD	R10,Y+8
    0021A 84B9      LDD	R11,Y+9
(0025) }
(0026) void EEPROM_write(u16 uiAddress,u8 *Data, int length)
(0027) {
(0028) 	int i;
(0029) 	for(i=0;i<length;i++){
    0021B 2744      CLR	R20
    0021C 2755      CLR	R21
    0021D C00A      RJMP	0x0228
(0030) 		EEPROM_write_byte(uiAddress+i,Data[i]);
    0021E 01FA      MOVW	R30,R20
    0021F 0DEC      ADD	R30,R12
    00220 1DFD      ADC	R31,R13
    00221 8120      LD	R18,Z
    00222 0187      MOVW	R16,R14
    00223 0F04      ADD	R16,R20
    00224 1F15      ADC	R17,R21
    00225 DFE0      RCALL	_EEPROM_write_byte
    00226 5F4F      SUBI	R20,0xFF
    00227 4F5F      SBCI	R21,0xFF
    00228 154A      CP	R20,R10
    00229 055B      CPC	R21,R11
    0022A F39C      BLT	0x021E
    0022B 940C 0367 JMP	pop_xgset30FC
_EEPROM_read:
  i                    --> R20
  length               --> R10
  Data                 --> R12
  uiAddress            --> R14
    0022D 940E 0372 CALL	push_xgset30FC
    0022F 0169      MOVW	R12,R18
    00230 0178      MOVW	R14,R16
    00231 84A8      LDD	R10,Y+8
    00232 84B9      LDD	R11,Y+9
(0031) 	}
(0032) }
(0033) void EEPROM_read(u16 uiAddress,u8 *Data, int length)
(0034) {
(0035) 	int i;
(0036) 	for(i=0;i<length;i++){
    00233 2744      CLR	R20
    00234 2755      CLR	R21
    00235 C00A      RJMP	0x0240
(0037) 		Data[i] = EEPROM_read_byte(uiAddress+i);
    00236 0187      MOVW	R16,R14
    00237 0F04      ADD	R16,R20
    00238 1F15      ADC	R17,R21
    00239 DFD4      RCALL	_EEPROM_read_byte
    0023A 01FA      MOVW	R30,R20
    0023B 0DEC      ADD	R30,R12
    0023C 1DFD      ADC	R31,R13
    0023D 8300      ST	Z,R16
    0023E 5F4F      SUBI	R20,0xFF
    0023F 4F5F      SBCI	R21,0xFF
    00240 154A      CP	R20,R10
    00241 055B      CPC	R21,R11
    00242 F39C      BLT	0x0236
    00243 940C 0367 JMP	pop_xgset30FC
FILE: D:\monitor\software\source\func.c
(0001) #include "define.h"
(0002) #include "uart.h"
(0003) #include "string.h"
(0004) #include "eeprom1.h"
(0005) 
(0006) extern u8 okflag;
(0007) extern u8 errflag;
(0008) extern u8 readflag;
(0009) extern u8 phnum[12];
(0010) extern u8 mstxt[100];
(0011) extern u8 key[10];
(0012) extern u8 key_old[10];
(0013) extern u8 shefang;
(0014) 
(0015) void send_message(char * str)
(0016) {
(0017) ;
_send_message:
  str                  --> Y,+0
    00245 9508      RET
_read_message:
    00246 9722      SBIW	R28,2
(0018) }
(0019) int read_message(void)//char * num,char * buff)
(0020) {
(0021) 	okflag = 0;
    00247 2422      CLR	R2
    00248 9220 011E STS	okflag,R2
(0022) 	memset(mstxt,0,100);
    0024A E684      LDI	R24,0x64
    0024B E090      LDI	R25,0
    0024C 8399      STD	Y+1,R25
    0024D 8388      ST	Y,R24
    0024E 2722      CLR	R18
    0024F 2733      CLR	R19
    00250 E907      LDI	R16,0x97
    00251 E010      LDI	R17,0
    00252 940E 0353 CALL	_memset
(0023) 	USART_send_str(" AT+CMGR=1");
    00254 E80A      LDI	R16,0x8A
    00255 E010      LDI	R17,0
    00256 940E 017D CALL	_USART_send_str
(0024) 	while((!okflag)&&(!errflag));
    00258 9020 011E LDS	R2,okflag
    0025A 2022      TST	R2
    0025B F421      BNE	0x0260
    0025C 9020 011D LDS	R2,errflag
    0025E 2022      TST	R2
    0025F F3C1      BEQ	0x0258
(0025) 	if(okflag)
    00260 9020 011E LDS	R2,okflag
    00262 2022      TST	R2
    00263 F019      BEQ	0x0267
(0026) 		return 0;
    00264 2700      CLR	R16
    00265 2711      CLR	R17
    00266 C002      RJMP	0x0269
(0027) 	else 
(0028) 		return -1;
    00267 EF0F      LDI	R16,0xFF
    00268 EF1F      LDI	R17,0xFF
    00269 9622      ADIW	R28,2
    0026A 9508      RET
_pass_phnum:
  i                    --> R20
    0026B 934A      ST	-Y,R20
    0026C 9722      SBIW	R28,2
(0029) }
(0030) int pass_phnum(void)
(0031) {
(0032) 	u8 i;
(0033) 	for(i=0;i<100 - 3;i++){
    0026D 2744      CLR	R20
    0026E C023      RJMP	0x0292
(0034) 		if(memcmp(mstxt+i,"+86",3) == 0){
    0026F E083      LDI	R24,3
    00270 E090      LDI	R25,0
    00271 8399      STD	Y+1,R25
    00272 8388      ST	Y,R24
    00273 E826      LDI	R18,0x86
    00274 E030      LDI	R19,0
    00275 E987      LDI	R24,0x97
    00276 E090      LDI	R25,0
    00277 2F04      MOV	R16,R20
    00278 2711      CLR	R17
    00279 0F08      ADD	R16,R24
    0027A 1F19      ADC	R17,R25
    0027B 940E 0333 CALL	_memcmp
    0027D 3000      CPI	R16,0
    0027E 0701      CPC	R16,R17
    0027F F489      BNE	0x0291
(0035) 			memcpy(phnum,mstxt+i+3,11);
    00280 E08B      LDI	R24,0xB
    00281 E090      LDI	R25,0
    00282 8399      STD	Y+1,R25
    00283 8388      ST	Y,R24
    00284 E98A      LDI	R24,0x9A
    00285 E090      LDI	R25,0
    00286 2F24      MOV	R18,R20
    00287 2733      CLR	R19
    00288 0F28      ADD	R18,R24
    00289 1F39      ADC	R19,R25
    0028A EF0B      LDI	R16,0xFB
    0028B E010      LDI	R17,0
    0028C 940E 0345 CALL	_memcpy
(0036) 			return 0;
    0028E 2700      CLR	R16
    0028F 2711      CLR	R17
    00290 C005      RJMP	0x0296
    00291 9543      INC	R20
    00292 3641      CPI	R20,0x61
    00293 F2D8      BCS	0x026F
(0037) 		}
(0038) 	}
(0039) 	return -1;
    00294 EF0F      LDI	R16,0xFF
    00295 EF1F      LDI	R17,0xFF
    00296 9622      ADIW	R28,2
    00297 9149      LD	R20,Y+
    00298 9508      RET
_pass_key:
  i                    --> R20
    00299 934A      ST	-Y,R20
    0029A 9722      SBIW	R28,2
(0040) }
(0041) 
(0042) int pass_key(void)
(0043) {
(0044) 	u8 i;
(0045) 	for(i=0;i<100 -3;i++){
    0029B 2744      CLR	R20
    0029C C031      RJMP	0x02CE
(0046) 		if(memcmp(mstxt+i,"key",3) == 0){
    0029D E083      LDI	R24,3
    0029E E090      LDI	R25,0
    0029F 8399      STD	Y+1,R25
    002A0 8388      ST	Y,R24
    002A1 E822      LDI	R18,0x82
    002A2 E030      LDI	R19,0
    002A3 E987      LDI	R24,0x97
    002A4 E090      LDI	R25,0
    002A5 2F04      MOV	R16,R20
    002A6 2711      CLR	R17
    002A7 0F08      ADD	R16,R24
    002A8 1F19      ADC	R17,R25
    002A9 940E 0333 CALL	_memcmp
    002AB 3000      CPI	R16,0
    002AC 0701      CPC	R16,R17
    002AD F4F9      BNE	0x02CD
(0047) 			memcpy(key_old,mstxt+i+3,6);
    002AE E086      LDI	R24,6
    002AF E090      LDI	R25,0
    002B0 8399      STD	Y+1,R25
    002B1 8388      ST	Y,R24
    002B2 E98A      LDI	R24,0x9A
    002B3 E090      LDI	R25,0
    002B4 2F24      MOV	R18,R20
    002B5 2733      CLR	R19
    002B6 0F28      ADD	R18,R24
    002B7 1F39      ADC	R19,R25
    002B8 E007      LDI	R16,7
    002B9 E011      LDI	R17,1
    002BA 940E 0345 CALL	_memcpy
(0048) 			memcpy(key,mstxt+i+10,6);
    002BC E086      LDI	R24,6
    002BD E090      LDI	R25,0
    002BE 8399      STD	Y+1,R25
    002BF 8388      ST	Y,R24
    002C0 EA81      LDI	R24,0xA1
    002C1 E090      LDI	R25,0
    002C2 2F24      MOV	R18,R20
    002C3 2733      CLR	R19
    002C4 0F28      ADD	R18,R24
    002C5 1F39      ADC	R19,R25
    002C6 E101      LDI	R16,0x11
    002C7 E011      LDI	R17,1
    002C8 940E 0345 CALL	_memcpy
(0049) 			return 0;
    002CA 2700      CLR	R16
    002CB 2711      CLR	R17
    002CC C005      RJMP	0x02D2
    002CD 9543      INC	R20
    002CE 3641      CPI	R20,0x61
    002CF F268      BCS	0x029D
(0050) 		}
(0051) 	}
(0052) 	return -1;
    002D0 EF0F      LDI	R16,0xFF
    002D1 EF1F      LDI	R17,0xFF
    002D2 9622      ADIW	R28,2
    002D3 9149      LD	R20,Y+
    002D4 9508      RET
_pass_commond:
  i                    --> R20
    002D5 934A      ST	-Y,R20
    002D6 9722      SBIW	R28,2
(0053) }
(0054) 
(0055) int pass_commond(void)
(0056) {
(0057) 	u8 i;
(0058) 	for(i=0;i<100 -3;i++){
    002D7 2744      CLR	R20
    002D8 C02F      RJMP	0x0308
(0059) 		if(memcmp(mstxt+i,"on",2) == 0){
    002D9 E082      LDI	R24,2
    002DA E090      LDI	R25,0
    002DB 8399      STD	Y+1,R25
    002DC 8388      ST	Y,R24
    002DD E72F      LDI	R18,0x7F
    002DE E030      LDI	R19,0
    002DF E987      LDI	R24,0x97
    002E0 E090      LDI	R25,0
    002E1 2F04      MOV	R16,R20
    002E2 2711      CLR	R17
    002E3 0F08      ADD	R16,R24
    002E4 1F19      ADC	R17,R25
    002E5 940E 0333 CALL	_memcmp
    002E7 3000      CPI	R16,0
    002E8 0701      CPC	R16,R17
    002E9 F431      BNE	0x02F0
(0060) 			shefang =1;
    002EA E081      LDI	R24,1
    002EB 9380 0096 STS	shefang,R24
(0061) 			return 0;
    002ED 2700      CLR	R16
    002EE 2711      CLR	R17
    002EF C01C      RJMP	0x030C
(0062) 		}
(0063) 		else if(memcmp(mstxt+i,"off",3) == 0){
    002F0 E083      LDI	R24,3
    002F1 E090      LDI	R25,0
    002F2 8399      STD	Y+1,R25
    002F3 8388      ST	Y,R24
    002F4 E72B      LDI	R18,0x7B
    002F5 E030      LDI	R19,0
    002F6 E987      LDI	R24,0x97
    002F7 E090      LDI	R25,0
    002F8 2F04      MOV	R16,R20
    002F9 2711      CLR	R17
    002FA 0F08      ADD	R16,R24
    002FB 1F19      ADC	R17,R25
    002FC 940E 0333 CALL	_memcmp
    002FE 3000      CPI	R16,0
    002FF 0701      CPC	R16,R17
    00300 F431      BNE	0x0307
(0064) 			shefang =0;
    00301 2422      CLR	R2
    00302 9220 0096 STS	shefang,R2
(0065) 			return 0;
    00304 2700      CLR	R16
    00305 2711      CLR	R17
    00306 C005      RJMP	0x030C
    00307 9543      INC	R20
    00308 3641      CPI	R20,0x61
    00309 F278      BCS	0x02D9
(0066) 		}
(0067) 			
(0068) 	}
(0069) 	return -1;
    0030A EF0F      LDI	R16,0xFF
    0030B EF1F      LDI	R17,0xFF
    0030C 9622      ADIW	R28,2
    0030D 9149      LD	R20,Y+
    0030E 9508      RET
_phcall:
  i                    --> Y,+3
  buff                 --> Y,+2
    0030F 9766      SBIW	R28,0x16
(0070) }
(0071) 
(0072) void phcall(void)
(0073) {
(0074) 	u8 buff[20];
(0075) 	u8 i;
(0076) #if TEST
(0077) 	phnum[]="13520813263";
(0078) #else
(0079) 	EEPROM_read(phnum_addr,phnum,phnum_length);
    00310 E08B      LDI	R24,0xB
    00311 E090      LDI	R25,0
    00312 8399      STD	Y+1,R25
    00313 8388      ST	Y,R24
    00314 EF2B      LDI	R18,0xFB
    00315 E030      LDI	R19,0
    00316 2700      CLR	R16
    00317 2711      CLR	R17
    00318 940E 022D CALL	_EEPROM_read
(0080) 	memcpy(buff,"ATD",3);
    0031A E083      LDI	R24,3
    0031B E090      LDI	R25,0
    0031C 8399      STD	Y+1,R25
    0031D 8388      ST	Y,R24
    0031E E727      LDI	R18,0x77
    0031F E030      LDI	R19,0
    00320 018E      MOVW	R16,R28
    00321 5F0E      SUBI	R16,0xFE
    00322 4F1F      SBCI	R17,0xFF
    00323 940E 0345 CALL	_memcpy
(0081) 	strcpy(buff+3,phnum);
    00325 EF2B      LDI	R18,0xFB
    00326 E030      LDI	R19,0
    00327 018E      MOVW	R16,R28
    00328 5F0B      SUBI	R16,0xFB
    00329 4F1F      SBCI	R17,0xFF
    0032A 940E 035E CALL	_strcpy
(0082) 	USART_send_str(buff);
FILE: <library>
    0032C 018E      MOVW	R16,R28
    0032D 5F0E      SUBI	R16,0xFE
    0032E 4F1F      SBCI	R17,0xFF
    0032F 940E 017D CALL	_USART_send_str
    00331 9666      ADIW	R28,0x16
    00332 9508      RET
_memcmp:
    00333 8188      LD	R24,Y
    00334 8199      LDD	R25,Y+1
    00335 3080      CPI	R24,0
    00336 0798      CPC	R25,R24
    00337 F051      BEQ	0x0342
    00338 2FA0      MOV	R26,R16
    00339 2FB1      MOV	R27,R17
    0033A 2FE2      MOV	R30,R18
    0033B 2FF3      MOV	R31,R19
    0033C 910D      LD	R16,X+
    0033D 9111      LD	R17,Z+
    0033E 1B01      SUB	R16,R17
    0033F F419      BNE	0x0343
    00340 9701      SBIW	R24,1
    00341 F7D1      BNE	0x033C
    00342 2700      CLR	R16
    00343 0B11      SBC	R17,R17
    00344 9508      RET
_memcpy:
    00345 2FA0      MOV	R26,R16
    00346 2FB1      MOV	R27,R17
    00347 2FE2      MOV	R30,R18
    00348 2FF3      MOV	R31,R19
    00349 8188      LD	R24,Y
    0034A 8199      LDD	R25,Y+1
    0034B 3080      CPI	R24,0
    0034C 0798      CPC	R25,R24
    0034D C003      RJMP	0x0351
    0034E 9001      LD	R0,Z+
    0034F 920D      ST	X+,R0
    00350 9701      SBIW	R24,1
    00351 F7E1      BNE	0x034E
    00352 9508      RET
_memset:
    00353 8188      LD	R24,Y
    00354 8199      LDD	R25,Y+1
    00355 3080      CPI	R24,0
    00356 0789      CPC	R24,R25
    00357 F029      BEQ	0x035D
    00358 2FE0      MOV	R30,R16
    00359 2FF1      MOV	R31,R17
    0035A 9321      ST	Z+,R18
    0035B 9701      SBIW	R24,1
    0035C F7E9      BNE	0x035A
    0035D 9508      RET
_strcpy:
    0035E 2FA0      MOV	R26,R16
    0035F 2FB1      MOV	R27,R17
    00360 2FE2      MOV	R30,R18
    00361 2FF3      MOV	R31,R19
    00362 9001      LD	R0,Z+
    00363 920D      ST	X+,R0
    00364 2000      TST	R0
    00365 F7E1      BNE	0x0362
    00366 9508      RET
pop_xgset30FC:
    00367 90A9      LD	R10,Y+
    00368 90B9      LD	R11,Y+
    00369 90C9      LD	R12,Y+
    0036A 90D9      LD	R13,Y+
    0036B 90E9      LD	R14,Y+
    0036C 90F9      LD	R15,Y+
    0036D 9149      LD	R20,Y+
    0036E 9159      LD	R21,Y+
    0036F 9508      RET
push_xgsetF0FC:
    00370 937A      ST	-Y,R23
    00371 936A      ST	-Y,R22
push_xgset30FC:
    00372 935A      ST	-Y,R21
    00373 934A      ST	-Y,R20
push_xgset00FC:
    00374 92FA      ST	-Y,R15
    00375 92EA      ST	-Y,R14
push_xgset003C:
    00376 92DA      ST	-Y,R13
    00377 92CA      ST	-Y,R12
    00378 92BA      ST	-Y,R11
    00379 92AA      ST	-Y,R10
    0037A 9508      RET
push_xgset300C:
    0037B 935A      ST	-Y,R21
    0037C 934A      ST	-Y,R20
    0037D 92BA      ST	-Y,R11
    0037E 92AA      ST	-Y,R10
    0037F 9508      RET
pop_xgset300C:
    00380 90A9      LD	R10,Y+
    00381 90B9      LD	R11,Y+
    00382 9149      LD	R20,Y+
    00383 9159      LD	R21,Y+
    00384 9508      RET
